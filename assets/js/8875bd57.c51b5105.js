"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2841],{48:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var i=t(5893),o=t(1151);const a={sidebar_position:2},r="AOP (Aspect Oriented Programming)",c={id:"java-advance/AOP",title:"AOP (Aspect Oriented Programming)",description:"T\xf3m t\u1eaft",source:"@site/docs/java-advance/AOP.md",sourceDirName:"java-advance",slug:"/java-advance/AOP",permalink:"/docs/java-advance/AOP",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"java.util.concurrent",permalink:"/docs/java-advance/java-util-concurrent"},next:{title:"Annotation",permalink:"/docs/java-advance/Annotation"}},s={},l=[{value:"T\xf3m t\u1eaft",id:"t\xf3m-t\u1eaft",level:2},{value:"Core concept",id:"core-concept",level:3},{value:"Types of advice",id:"types-of-advice",level:3},{value:"join point",id:"join-point",level:3},{value:"Around",id:"around",level:3},{value:"Advice with custom annotation point cut",id:"advice-with-custom-annotation-point-cut",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"aop-aspect-oriented-programming",children:"AOP (Aspect Oriented Programming)"}),"\n",(0,i.jsx)(n.h2,{id:"t\xf3m-t\u1eaft",children:"T\xf3m t\u1eaft"}),"\n",(0,i.jsx)(n.h3,{id:"core-concept",children:"Core concept"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Aspect: is a class that implement cross-cutting concern. using @Aspect annotation"}),"\n",(0,i.jsxs)(n.li,{children:["Join Point: is a specific point that execution a method.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"we can use join point as parametor in advice method to get method signature or target objects."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Advice: is action taken for a join point (method executed when a certain join point matching pointcut) using @Before, @After, @Around, @AfterReturning, @AfterThrowing"}),"\n",(0,i.jsxs)(n.li,{children:["Pointcut: is a expression that match with join points","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"sometimes we have to use same Pointcut in multiple places, we can create an empty method with @Pointcut Annotation."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Target Object: Spring AOP is implemented using runtime proxy."}),"\n",(0,i.jsx)(n.li,{children:"Weaving: it is the process of link aspect with other objects to create the advise proxy objects (AOP perform weaving at runtime)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"types-of-advice",children:"Types of advice"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Before advice: run before the method."}),"\n",(0,i.jsx)(n.li,{children:"After (finally) advice: run after the method."}),"\n",(0,i.jsx)(n.li,{children:"After returning advice: run after the method completes successfully"}),"\n",(0,i.jsx)(n.li,{children:"After throwing advice: run after the method exits by throwing an exception"}),"\n",(0,i.jsx)(n.li,{children:"Aroud advice: run before and after the method"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Aspect\npublic class EmployeeAfterAspect {\n\t@After("args(name)")\n\tpublic void logStringArguments(String name){\n\t\tSystem.out.println("Running After Advice. String argument passed="+name);\n\t}\n    // We can use within in pointcut expression to apply the advice to all the methods in the class\n\t@AfterThrowing("within(com.journaldev.spring.model.Employee)")\n\tpublic void logExceptions(JoinPoint joinPoint){\n\t\tSystem.out.println("Exception thrown in Employee Method="+joinPoint.toString());\n\t}\n\t@AfterReturning(pointcut="execution(* getName())", returning="returnString")\n\tpublic void getNameReturningAdvice(String returnString){\n\t\tSystem.out.println("getNameReturningAdvice executed. Returned String="+returnString);\n\t}\n\t\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"join-point",children:"join point"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"example"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Aspect\npublic class EmployeeAspectJoinPoint {\n\t@Before("execution(public void com.journaldev.spring.model..set*(*))")\n\tpublic void loggingAdvice(JoinPoint joinPoint){\n\t\tSystem.out.println("Before running loggingAdvice on method="+joinPoint.toString());\n\t\tSystem.out.println("Agruments Passed=" + Arrays.toString(joinPoint.getArgs()));\n\t}\n\t//Advice arguments, will be applied to bean methods with single String argument\n\t@Before("args(name)")\n\tpublic void logStringArguments(String name){\n\t\tSystem.out.println("String argument passed="+name);\n\t}\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"around",children:"Around"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"example"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Aspect\npublic class EmployeeAroundAspect {\n\n\t@Around("execution(* com.journaldev.spring.model.Employee.getName())")\n\tpublic Object employeeAroundAdvice(ProceedingJoinPoint proceedingJoinPoint){\n\t\tSystem.out.println("Before invoking getName() method");\n\t\tObject value = null;\n\t\ttry {\n\t\t\tvalue = proceedingJoinPoint.proceed();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println("After invoking getName() method. Return value="+value);\n\t\treturn value;\n\t}\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Around advice are always required to have ProceedingJoinPoint as an argument and we should use it\u2019s proceed() method to invoke the target object advised method.\nIf advised method is returning something, it\u2019s advice responsibility to return it to the caller program. For void methods, advice method can return null.\nSince around advice cut around the advised method, we can control the input and output of the method as well as it\u2019s execution behavior."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"advice-with-custom-annotation-point-cut",children:"Advice with custom annotation point cut"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If you look at all the above advice pointcut expressions, there are chances that they get applied to some other beans where it\u2019s not intended.\nFor example, someone can define a new spring bean with getName() method and the advice will start getting applied to that even though it was not intended.\nThat\u2019s why we should keep the scope of pointcut expression as narrow as possible. An alternative approach is to create a custom annotation and\nannotate the methods where we want the advice to be applied"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"package com.journaldev.spring.aspect;\npublic @interface Loggable {\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'package com.journaldev.spring.aspect;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\n\n@Aspect\npublic class EmployeeAnnotationAspect {\n\t@Before("@annotation(com.journaldev.spring.aspect.Loggable)")\n\tpublic void myAdvice(){\n\t\tSystem.out.println("Executing myAdvice!!");\n\t}\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>r});var i=t(7294);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);